import { createRequire } from 'node:module';
import { getIconData } from '@iconify/utils';
import { encodeSvgForCss } from '@iconify/utils/lib/svg/encode-svg-for-css';
import { readFileSync } from 'node:fs';
import { resolve, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';

const builtinIcons = {
  // package managers
  "pnpm": "vscode-icons:file-type-light-pnpm",
  "npm": "vscode-icons:file-type-npm",
  "yarn": "vscode-icons:file-type-yarn",
  "bun": "vscode-icons:file-type-bun",
  "deno": "vscode-icons:file-type-light-deno",
  // frameworks
  "vue": "vscode-icons:file-type-vue",
  "svelte": "vscode-icons:file-type-svelte",
  "angular": "vscode-icons:file-type-angular",
  "react": "vscode-icons:file-type-reactjs",
  "next": "vscode-icons:file-type-light-next",
  "nuxt": "vscode-icons:file-type-nuxt",
  "solid": "logos:solidjs-icon",
  "astro": "vscode-icons:file-type-light-astro",
  // bundlers
  "rollup": "vscode-icons:file-type-rollup",
  "webpack": "vscode-icons:file-type-webpack",
  "vite": "vscode-icons:file-type-vite",
  "esbuild": "vscode-icons:file-type-esbuild",
  // configuration files
  "package.json": "vscode-icons:file-type-node",
  "tsconfig.json": "vscode-icons:file-type-tsconfig",
  ".npmrc": "vscode-icons:file-type-npm",
  ".editorconfig": "vscode-icons:file-type-editorconfig",
  ".eslintrc": "vscode-icons:file-type-eslint",
  ".eslintignore": "vscode-icons:file-type-eslint",
  "eslint.config": "vscode-icons:file-type-eslint",
  ".gitignore": "vscode-icons:file-type-git",
  ".gitattributes": "vscode-icons:file-type-git",
  ".env": "vscode-icons:file-type-dotenv",
  ".env.example": "vscode-icons:file-type-dotenv",
  ".vscode": "vscode-icons:file-type-vscode",
  "tailwind.config": "vscode-icons:file-type-tailwind",
  "uno.config": "vscode-icons:file-type-unocss",
  // filename extensions
  ".ts": "vscode-icons:file-type-typescript",
  ".tsx": "vscode-icons:file-type-typescript",
  ".mjs": "vscode-icons:file-type-js",
  ".cjs": "vscode-icons:file-type-js",
  ".js": "vscode-icons:file-type-js",
  ".jsx": "vscode-icons:file-type-js",
  ".md": "vscode-icons:file-type-markdown",
  ".py": "vscode-icons:file-type-python",
  ".ico": "vscode-icons:file-type-favicon",
  ".html": "vscode-icons:file-type-html",
  ".yml": "vscode-icons:file-type-light-yaml",
  ".yaml": "vscode-icons:file-type-light-yaml"
};

async function generateCSS(labels, options) {
  const baseCSS = `
.vp-code-group [data-title]::before {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.5em;
  margin-bottom: -0.2em;
  background: var(--icon) no-repeat center / contain;
}`;
  const mergedIcons = { ...builtinIcons, ...options.customIcon };
  const matched = getMatchedLabels(labels, mergedIcons);
  const css = baseCSS + await generateIconCSS(matched);
  return { css };
}
function getMatchedLabels(labels, icons) {
  const matched = {};
  for (const label of labels) {
    const key = Object.keys(icons).find((k) => label?.toLowerCase().includes(k));
    if (key) {
      matched[icons[key]] = (matched[icons[key]] || []).concat(label);
    }
  }
  return matched;
}
async function generateIconCSS(matched) {
  const iconCSS = await Promise.all(Object.entries(matched).map(async ([icon, labels]) => {
    const svg = await getSVG(icon);
    const selector = labels.map((label) => `[data-title^='${label}']::before`).join(",");
    return `
${selector} {
  content: '';
  --icon: url("data:image/svg+xml,${svg}");
}`;
  }));
  return iconCSS.join("");
}
async function getSVG(icon) {
  if (icon.startsWith("<svg")) {
    return encodeSvgForCss(icon);
  }
  const [collection, iconName] = icon.split(":");
  try {
    const { icons } = createRequire(import.meta.url)(`@iconify-json/${collection}`);
    const iconData = getIconData(icons, iconName);
    if (iconData) {
      const { top = 0, left = 0, width = 0, height = 0, body } = iconData;
      const svg = `<svg xmlns='http://www.w3.org/2000/svg' viewBox='${top} ${left} ${width} ${height}'>${body}</svg>`;
      return encodeSvgForCss(svg);
    }
    return "";
  } catch {
    console.warn(`[vitepress-plugin-group-icons]: Icon set \`${collection}\` not found. Please install \`@iconify-json/${collection}\` first`);
    return "";
  }
}

function isSetEqual(set1, set2) {
  try {
    if (set1.size !== set2.size) {
      return false;
    }
    for (const item of set1) {
      if (!set2.has(item)) {
        return false;
      }
    }
    return true;
  } catch {
    return false;
  }
}

function groupIconVitePlugin(options) {
  const virtualCssId = "virtual:group-icons.css";
  const resolvedVirtualCssId = `\0${virtualCssId}`;
  const labelMatchs = /* @__PURE__ */ new Set();
  let oldLabelMatchs;
  const labelMatchRegex = /<label[^>]+\bdata-title=\\"([^"]*)\\"|<label[^>]+\bdata-title="[^"]*"/g;
  let server;
  options = options || { customIcon: {} };
  function handleUpdateModule() {
    const mod = server?.moduleGraph.getModuleById(resolvedVirtualCssId);
    if (mod) {
      server.moduleGraph.invalidateModule(mod);
      server.reloadModule(mod);
    }
  }
  return {
    name: "vitepress-plugin-group-icons",
    enforce: "post",
    resolveId(id) {
      if (id === virtualCssId) {
        return resolvedVirtualCssId;
      }
      return void 0;
    },
    configureServer(_server) {
      server = _server;
    },
    async load(id) {
      if (id === resolvedVirtualCssId) {
        const { css } = await generateCSS(labelMatchs, options);
        oldLabelMatchs = new Set(labelMatchs);
        return css;
      }
      return void 0;
    },
    transform(code, id) {
      if (!id.endsWith(".md"))
        return;
      while (true) {
        const match = labelMatchRegex.exec(code);
        if (!match)
          break;
        labelMatchs.add(match[1]);
      }
      if (!isSetEqual(labelMatchs, oldLabelMatchs)) {
        handleUpdateModule();
      }
    }
  };
}

function localIconLoader(url, path) {
  return readFileSync(resolve(dirname(fileURLToPath(url)), path), "utf-8");
}

function groupIconMdPlugin(md) {
  const labelRE = /<label\b(?![^>]+\bdata-title\b)[^>]*>(.*?)<\/label>/g;
  const orig = md.renderer.rules["container_code-group_open"] || function(...args) {
    return args[1];
  };
  md.renderer.rules["container_code-group_open"] = (...args) => {
    return orig(...args).replace(
      labelRE,
      (match, label) => `<label data-title="${md.utils.escapeHtml(label)}"${match.slice(6)}`
    );
  };
}

export { groupIconMdPlugin, groupIconVitePlugin, localIconLoader };
